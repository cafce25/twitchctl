use crate::api::{ApiClient, UserIdent};
use crate::{exit, warning};
use fuzzy_filter::FuzzyFilter;
use structopt::StructOpt;
use twitch_api2::{
    helix::tags::{AutoGenerated, TwitchTag},
    types::{UserId, UserName},
};

#[derive(Debug, StructOpt)]
/// manipulate a streams tags
pub struct TagsOptions {
    /// the locale to use for the tag names
    #[structopt(short, long, default_value = "en-us")]
    pub locale: String,

    #[structopt(subcommand)]
    pub subcommand: TagsSubcommand,
}

#[derive(Debug, StructOpt)]
pub enum TagsSubcommand {
    /// list all available tags
    ListAll {
        #[structopt(flatten)]
        shared: SharedTagsOptions,
    },
    /// list tags for a broadcaster
    List {
        /// the name of the broadcaster for which to list the tags
        ///
        /// if omitted the token user is used
        #[structopt(flatten)]
        broadcaster: BroadcasterOption,
        #[structopt(flatten)]
        shared: SharedTagsOptions,
    },
    /// set all tags for a broadcaster, or the owner of the auth token
    Set {
        #[structopt(flatten)]
        broadcaster: BroadcasterOption,
        /// the tags to set for the stream
        tags: Vec<String>,
        /// add tags instead of replacing
        #[structopt(short, long)]
        add: bool,
    },
}

#[derive(Debug, StructOpt)]
pub struct BroadcasterOption {
    /// the name of the broadcaster
    #[structopt(short, long, conflicts_with = "broadcaster_id")]
    broadcaster: Option<UserName>,

    /// the id of the broadcaster
    #[structopt(long)]
    broadcaster_id: Option<UserId>,
}

#[derive(Debug, StructOpt)]
pub struct SharedTagsOptions {
    /// print tags in long format
    #[structopt(short)]
    long: bool,
    /// string for fuzzy filtering of tags
    filter: Option<String>,
}

pub async fn tags(client: ApiClient<'_>, locale: &str, command: TagsSubcommand) {
    match command {
        TagsSubcommand::ListAll {
            shared: SharedTagsOptions { long, filter },
        } => match client.get_all_tags().await {
            Ok(tags) => list(&tags, locale, filter, long),
            Err(e) => exit!(1, "An error occurred while fetching the tags: {}", e),
        },

        TagsSubcommand::List {
            shared: SharedTagsOptions { long, filter },
            broadcaster:
                BroadcasterOption {
                    broadcaster,
                    broadcaster_id,
                },
        } => {
            let id = get_broadcaster_id_or_die(&client, broadcaster, broadcaster_id).await;
            let tags = client.get_stream_tags(&id);
            match tags.await {
                Ok(tags) => list(&tags, locale, filter, long),
                Err(e) => exit!(1, "An error occurred while fetching the tags: {}", e),
            }
        }

        TagsSubcommand::Set {
            broadcaster:
                BroadcasterOption {
                    broadcaster,
                    broadcaster_id,
                },
            tags,
            add,
        } => {
            let broadcaster_id =
                get_broadcaster_id_or_die(&client, broadcaster, broadcaster_id).await;
            let current_tags = async {
                if add {
                    client
                        .get_stream_tags(&broadcaster_id)
                        .await
                        .unwrap_or(vec![])
                        .iter()
                        .filter_map(|v| {
                            if v.is_auto == AutoGenerated::True {
                                Some(v.id.clone())
                            } else {
                                None
                            }
                        })
                        .collect()
                } else {
                    vec![]
                }
            };

            let mut new_tags = match client.get_tag_ids_matching(tags.as_slice(), locale).await {
                Ok(tags) => tags,
                Err(_) => exit!(
                    1,
                    "Did not receive any localized data for locale {}",
                    locale
                ),
            };

            if new_tags.len() != tags.len() {
                warning!(
                    "Could not convert all tags to tag ids. \
                    Check if all Tags are set correctly with `twitchctl tags list`"
                );
            }

            let mut current_tags = current_tags.await;
            current_tags.append(&mut new_tags);
            match client
                .replace_stream_tags(&broadcaster_id, current_tags)
                .await
            {
                Ok(_) => {}
                Err(e) => exit!(1, "{}", e),
            }
        }
    }
}

async fn get_broadcaster_id_or_die(
    client: &ApiClient<'_>,
    broadcaster: Option<String>,
    broadcaster_id: Option<String>,
) -> UserId {
    let broadcaster_id = match (broadcaster, broadcaster_id) {
        (_, Some(i)) => client.get_broadcaster_id(UserIdent::UserId(i.into())),
        (Some(b), _) => client.get_broadcaster_id(UserIdent::UserName(b.into())),
        _ => client.get_broadcaster_id(UserIdent::None),
    }
    .await;

    match broadcaster_id {
        Ok(id) => id,
        Err(e) => exit!(1, "{}", e),
    }
}

fn list(tags: &[TwitchTag], locale: &str, filter: Option<String>, long: bool) {
    let filter = filter.as_ref().map(|f| f.to_lowercase());
    let filter = filter.as_ref().map(|f| FuzzyFilter::new(f));

    let max_len = tags
        .iter()
        .map(|tag| match tag.localization_names.get(locale) {
            Some(localized_name) => localized_name.len(),
            _ => exit!(
                1,
                "The locale '{}' was not found in the tags returned by Twitch",
                locale
            ),
        })
        .max()
        .unwrap_or(0);

    for tag in tags {
        let tag_name = tag.localization_names.get(locale).expect("valid locale");
        if match &filter {
            Some(filter) => filter.matches(&tag_name.to_lowercase()),
            _ => true,
        } {
            if long {
                let tag_description = tag
                    .localization_descriptions
                    .get(locale)
                    .expect("valid locale");
                println!(
                    "'{}'{}{}",
                    tag_name,
                    " ".repeat(1 + max_len.saturating_sub(tag_name.len())),
                    tag_description
                );
            } else {
                print!("'{}' ", tag_name);
            }
        }
    }
    if !long {
        println!()
    }
}
